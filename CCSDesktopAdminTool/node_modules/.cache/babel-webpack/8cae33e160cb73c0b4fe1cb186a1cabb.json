{"ast":null,"code":"/**\r\n* vkBeautify - javascript plugin to pretty-print or minify text in XML, JSON, CSS and SQL formats.\r\n*\r\n* Copyright (c) 2012 Vadim Kiryukhin\r\n* vkiryukhin @ gmail.com\r\n* http://www.eslinstructor.net/vkbeautify/\r\n*\r\n* Dual licensed under the MIT and GPL licenses:\r\n*   http://www.opensource.org/licenses/mit-license.php\r\n*   http://www.gnu.org/licenses/gpl.html\r\n*\r\n*   Pretty print\r\n*\r\n*        vkbeautify.xml(text [,indent_pattern]);\r\n*        vkbeautify.json(text [,indent_pattern]);\r\n*        vkbeautify.css(text [,indent_pattern]);\r\n*        vkbeautify.sql(text [,indent_pattern]);\r\n*\r\n*        @text - String; text to beatufy;\r\n*        @indent_pattern - Integer | String;\r\n*                Integer:  number of white spaces;\r\n*                String:   character string to visualize indentation ( can also be a set of white spaces )\r\n*   Minify\r\n*\r\n*        vkbeautify.xmlmin(text [,preserve_comments]);\r\n*        vkbeautify.jsonmin(text);\r\n*        vkbeautify.cssmin(text [,preserve_comments]);\r\n*        vkbeautify.sqlmin(text);\r\n*\r\n*        @text - String; text to minify;\r\n*        @preserve_comments - Bool; [optional];\r\n*                Set this flag to true to prevent removing comments from @text ( minxml and mincss functions only. )\r\n*\r\n*   Examples:\r\n*        vkbeautify.xml(text); // pretty print XML\r\n*        vkbeautify.json(text, 4 ); // pretty print JSON\r\n*        vkbeautify.css(text, '. . . .'); // pretty print CSS\r\n*        vkbeautify.sql(text, '----'); // pretty print SQL\r\n*\r\n*        vkbeautify.xmlmin(text, true);// minify XML, preserve comments\r\n*        vkbeautify.jsonmin(text);// minify JSON\r\n*        vkbeautify.cssmin(text);// minify CSS, remove comments ( default )\r\n*        vkbeautify.sqlmin(text);// minify SQL\r\n*\r\n*/\nfunction createShiftArr(step) {\n  var space = '    ';\n\n  if (isNaN(parseInt(step))) {\n    // argument is string\n    space = step;\n  } else {\n    // argument is integer\n    switch (step) {\n      case 1:\n        space = ' ';\n        break;\n\n      case 2:\n        space = '  ';\n        break;\n\n      case 3:\n        space = '   ';\n        break;\n\n      case 4:\n        space = '    ';\n        break;\n\n      case 5:\n        space = '     ';\n        break;\n\n      case 6:\n        space = '      ';\n        break;\n\n      case 7:\n        space = '       ';\n        break;\n\n      case 8:\n        space = '        ';\n        break;\n\n      case 9:\n        space = '         ';\n        break;\n\n      case 10:\n        space = '          ';\n        break;\n\n      case 11:\n        space = '           ';\n        break;\n\n      case 12:\n        space = '            ';\n        break;\n    }\n  }\n\n  var shift = ['\\n']; // array of shifts\n\n  for (var ix = 0; ix < 100; ix++) {\n    shift.push(shift[ix] + space);\n  }\n\n  return shift;\n}\n\nfunction vkbeautify() {\n  this.step = '    '; // 4 spaces\n\n  this.shift = createShiftArr(this.step);\n}\n\n;\n\nvkbeautify.prototype.xml = function (text, step) {\n  var ar = text.replace(/>\\s{0,}</g, \"><\").replace(/</g, \"~::~<\").replace(/\\s*xmlns\\:/g, \"~::~xmlns:\").replace(/\\s*xmlns\\=/g, \"~::~xmlns=\").split('~::~'),\n      len = ar.length,\n      inComment = false,\n      deep = 0,\n      str = '',\n      ix = 0,\n      shift = step ? createShiftArr(step) : this.shift;\n\n  for (ix = 0; ix < len; ix++) {\n    // start comment or <![CDATA[...]]> or <!DOCTYPE //\n    if (ar[ix].search(/<!/) > -1) {\n      str += shift[deep] + ar[ix];\n      inComment = true; // end comment  or <![CDATA[...]]> //\n\n      if (ar[ix].search(/-->/) > -1 || ar[ix].search(/\\]>/) > -1 || ar[ix].search(/!DOCTYPE/) > -1) {\n        inComment = false;\n      }\n    } else // end comment  or <![CDATA[...]]> //\n      if (ar[ix].search(/-->/) > -1 || ar[ix].search(/\\]>/) > -1) {\n        str += ar[ix];\n        inComment = false;\n      } else // <elm></elm> //\n        if (/^<\\w/.exec(ar[ix - 1]) && /^<\\/\\w/.exec(ar[ix]) && /^<[\\w:\\-\\.\\,]+/.exec(ar[ix - 1]) == /^<\\/[\\w:\\-\\.\\,]+/.exec(ar[ix])[0].replace('/', '')) {\n          str += ar[ix];\n          if (!inComment) deep--;\n        } else // <elm> //\n          if (ar[ix].search(/<\\w/) > -1 && ar[ix].search(/<\\//) == -1 && ar[ix].search(/\\/>/) == -1) {\n            str = !inComment ? str += shift[deep++] + ar[ix] : str += ar[ix];\n          } else // <elm>...</elm> //\n            if (ar[ix].search(/<\\w/) > -1 && ar[ix].search(/<\\//) > -1) {\n              str = !inComment ? str += shift[deep] + ar[ix] : str += ar[ix];\n            } else // </elm> //\n              if (ar[ix].search(/<\\//) > -1) {\n                str = !inComment ? str += shift[--deep] + ar[ix] : str += ar[ix];\n              } else // <elm/> //\n                if (ar[ix].search(/\\/>/) > -1) {\n                  str = !inComment ? str += shift[deep] + ar[ix] : str += ar[ix];\n                } else // <? xml ... ?> //\n                  if (ar[ix].search(/<\\?/) > -1) {\n                    str += shift[deep] + ar[ix];\n                  } else // xmlns //\n                    if (ar[ix].search(/xmlns\\:/) > -1 || ar[ix].search(/xmlns\\=/) > -1) {\n                      str += shift[deep] + ar[ix];\n                    } else {\n                      str += ar[ix];\n                    }\n  }\n\n  return str[0] == '\\n' ? str.slice(1) : str;\n};\n\nvkbeautify.prototype.json = function (text, step) {\n  var step = step ? step : this.step;\n  if (typeof JSON === 'undefined') return text;\n  if (typeof text === \"string\") return JSON.stringify(JSON.parse(text), null, step);\n  if (typeof text === \"object\") return JSON.stringify(text, null, step);\n  return text; // text is not string nor object\n};\n\nvkbeautify.prototype.css = function (text, step) {\n  var ar = text.replace(/\\s{1,}/g, ' ').replace(/\\{/g, \"{~::~\").replace(/\\}/g, \"~::~}~::~\").replace(/\\;/g, \";~::~\").replace(/\\/\\*/g, \"~::~/*\").replace(/\\*\\//g, \"*/~::~\").replace(/~::~\\s{0,}~::~/g, \"~::~\").split('~::~'),\n      len = ar.length,\n      deep = 0,\n      str = '',\n      ix = 0,\n      shift = step ? createShiftArr(step) : this.shift;\n\n  for (ix = 0; ix < len; ix++) {\n    if (/\\{/.exec(ar[ix])) {\n      str += shift[deep++] + ar[ix];\n    } else if (/\\}/.exec(ar[ix])) {\n      str += shift[--deep] + ar[ix];\n    } else if (/\\*\\\\/.exec(ar[ix])) {\n      str += shift[deep] + ar[ix];\n    } else {\n      str += shift[deep] + ar[ix];\n    }\n  }\n\n  return str.replace(/^\\n{1,}/, '');\n}; //----------------------------------------------------------------------------\n\n\nfunction isSubquery(str, parenthesisLevel) {\n  return parenthesisLevel - (str.replace(/\\(/g, '').length - str.replace(/\\)/g, '').length);\n}\n\nfunction split_sql(str, tab) {\n  return str.replace(/\\s{1,}/g, \" \").replace(/ AND /ig, \"~::~\" + tab + tab + \"AND \").replace(/ BETWEEN /ig, \"~::~\" + tab + \"BETWEEN \").replace(/ CASE /ig, \"~::~\" + tab + \"CASE \").replace(/ ELSE /ig, \"~::~\" + tab + \"ELSE \").replace(/ END /ig, \"~::~\" + tab + \"END \").replace(/ FROM /ig, \"~::~FROM \").replace(/ GROUP\\s{1,}BY/ig, \"~::~GROUP BY \").replace(/ HAVING /ig, \"~::~HAVING \") //.replace(/ SET /ig,\" SET~::~\")\n  .replace(/ IN /ig, \" IN \").replace(/ JOIN /ig, \"~::~JOIN \").replace(/ CROSS~::~{1,}JOIN /ig, \"~::~CROSS JOIN \").replace(/ INNER~::~{1,}JOIN /ig, \"~::~INNER JOIN \").replace(/ LEFT~::~{1,}JOIN /ig, \"~::~LEFT JOIN \").replace(/ RIGHT~::~{1,}JOIN /ig, \"~::~RIGHT JOIN \").replace(/ ON /ig, \"~::~\" + tab + \"ON \").replace(/ OR /ig, \"~::~\" + tab + tab + \"OR \").replace(/ ORDER\\s{1,}BY/ig, \"~::~ORDER BY \").replace(/ OVER /ig, \"~::~\" + tab + \"OVER \").replace(/\\(\\s{0,}SELECT /ig, \"~::~(SELECT \").replace(/\\)\\s{0,}SELECT /ig, \")~::~SELECT \").replace(/ THEN /ig, \" THEN~::~\" + tab + \"\").replace(/ UNION /ig, \"~::~UNION~::~\").replace(/ USING /ig, \"~::~USING \").replace(/ WHEN /ig, \"~::~\" + tab + \"WHEN \").replace(/ WHERE /ig, \"~::~WHERE \").replace(/ WITH /ig, \"~::~WITH \") //.replace(/\\,\\s{0,}\\(/ig,\",~::~( \")\n  //.replace(/\\,/ig,\",~::~\"+tab+tab+\"\")\n  .replace(/ ALL /ig, \" ALL \").replace(/ AS /ig, \" AS \").replace(/ ASC /ig, \" ASC \").replace(/ DESC /ig, \" DESC \").replace(/ DISTINCT /ig, \" DISTINCT \").replace(/ EXISTS /ig, \" EXISTS \").replace(/ NOT /ig, \" NOT \").replace(/ NULL /ig, \" NULL \").replace(/ LIKE /ig, \" LIKE \").replace(/\\s{0,}SELECT /ig, \"SELECT \").replace(/\\s{0,}UPDATE /ig, \"UPDATE \").replace(/ SET /ig, \" SET \").replace(/~::~{1,}/g, \"~::~\").split('~::~');\n}\n\nvkbeautify.prototype.sql = function (text, step) {\n  var ar_by_quote = text.replace(/\\s{1,}/g, \" \").replace(/\\'/ig, \"~::~\\'\").split('~::~'),\n      len = ar_by_quote.length,\n      ar = [],\n      deep = 0,\n      tab = this.step,\n      //+this.step,\n  inComment = true,\n      inQuote = false,\n      parenthesisLevel = 0,\n      str = '',\n      ix = 0,\n      shift = step ? createShiftArr(step) : this.shift;\n  ;\n\n  for (ix = 0; ix < len; ix++) {\n    if (ix % 2) {\n      ar = ar.concat(ar_by_quote[ix]);\n    } else {\n      ar = ar.concat(split_sql(ar_by_quote[ix], tab));\n    }\n  }\n\n  len = ar.length;\n\n  for (ix = 0; ix < len; ix++) {\n    parenthesisLevel = isSubquery(ar[ix], parenthesisLevel);\n\n    if (/\\s{0,}\\s{0,}SELECT\\s{0,}/.exec(ar[ix])) {\n      ar[ix] = ar[ix].replace(/\\,/g, \",\\n\" + tab + tab + \"\");\n    }\n\n    if (/\\s{0,}\\s{0,}SET\\s{0,}/.exec(ar[ix])) {\n      ar[ix] = ar[ix].replace(/\\,/g, \",\\n\" + tab + tab + \"\");\n    }\n\n    if (/\\s{0,}\\(\\s{0,}SELECT\\s{0,}/.exec(ar[ix])) {\n      deep++;\n      str += shift[deep] + ar[ix];\n    } else if (/\\'/.exec(ar[ix])) {\n      if (parenthesisLevel < 1 && deep) {\n        deep--;\n      }\n\n      str += ar[ix];\n    } else {\n      str += shift[deep] + ar[ix];\n\n      if (parenthesisLevel < 1 && deep) {\n        deep--;\n      }\n    }\n\n    var junk = 0;\n  }\n\n  str = str.replace(/^\\n{1,}/, '').replace(/\\n{1,}/g, \"\\n\");\n  return str;\n};\n\nvkbeautify.prototype.xmlmin = function (text, preserveComments) {\n  var str = preserveComments ? text : text.replace(/\\<![ \\r\\n\\t]*(--([^\\-]|[\\r\\n]|-[^\\-])*--[ \\r\\n\\t]*)\\>/g, \"\").replace(/[ \\r\\n\\t]{1,}xmlns/g, ' xmlns');\n  return str.replace(/>\\s{0,}</g, \"><\");\n};\n\nvkbeautify.prototype.jsonmin = function (text) {\n  if (typeof JSON === 'undefined') return text;\n  return JSON.stringify(JSON.parse(text), null, 0);\n};\n\nvkbeautify.prototype.cssmin = function (text, preserveComments) {\n  var str = preserveComments ? text : text.replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*+\\//g, \"\");\n  return str.replace(/\\s{1,}/g, ' ').replace(/\\{\\s{1,}/g, \"{\").replace(/\\}\\s{1,}/g, \"}\").replace(/\\;\\s{1,}/g, \";\").replace(/\\/\\*\\s{1,}/g, \"/*\").replace(/\\*\\/\\s{1,}/g, \"*/\");\n};\n\nvkbeautify.prototype.sqlmin = function (text) {\n  return text.replace(/\\s{1,}/g, \" \").replace(/\\s{1,}\\(/, \"(\").replace(/\\s{1,}\\)/, \")\");\n};\n\nmodule.exports = new vkbeautify();","map":null,"metadata":{},"sourceType":"script"}