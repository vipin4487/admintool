{"ast":null,"code":"import _classCallCheck from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nvar defaultMaxFrame = 750;\nexport var TestScheduler = /*#__PURE__*/function (_VirtualTimeScheduler) {\n  _inherits(TestScheduler, _VirtualTimeScheduler);\n\n  var _super = _createSuper(TestScheduler);\n\n  function TestScheduler(assertDeepEqual) {\n    var _this;\n\n    _classCallCheck(this, TestScheduler);\n\n    _this = _super.call(this, VirtualAction, defaultMaxFrame);\n    _this.assertDeepEqual = assertDeepEqual;\n    _this.hotObservables = [];\n    _this.coldObservables = [];\n    _this.flushTests = [];\n    _this.runMode = false;\n    return _this;\n  }\n\n  _createClass(TestScheduler, [{\n    key: \"createTime\",\n    value: function createTime(marbles) {\n      var indexOf = marbles.indexOf('|');\n\n      if (indexOf === -1) {\n        throw new Error('marble diagram for time should have a completion marker \"|\"');\n      }\n\n      return indexOf * TestScheduler.frameTimeFactor;\n    }\n  }, {\n    key: \"createColdObservable\",\n    value: function createColdObservable(marbles, values, error) {\n      if (marbles.indexOf('^') !== -1) {\n        throw new Error('cold observable cannot have subscription offset \"^\"');\n      }\n\n      if (marbles.indexOf('!') !== -1) {\n        throw new Error('cold observable cannot have unsubscription marker \"!\"');\n      }\n\n      var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n      var cold = new ColdObservable(messages, this);\n      this.coldObservables.push(cold);\n      return cold;\n    }\n  }, {\n    key: \"createHotObservable\",\n    value: function createHotObservable(marbles, values, error) {\n      if (marbles.indexOf('!') !== -1) {\n        throw new Error('hot observable cannot have unsubscription marker \"!\"');\n      }\n\n      var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n      var subject = new HotObservable(messages, this);\n      this.hotObservables.push(subject);\n      return subject;\n    }\n  }, {\n    key: \"materializeInnerObservable\",\n    value: function materializeInnerObservable(observable, outerFrame) {\n      var _this2 = this;\n\n      var messages = [];\n      observable.subscribe(function (value) {\n        messages.push({\n          frame: _this2.frame - outerFrame,\n          notification: Notification.createNext(value)\n        });\n      }, function (err) {\n        messages.push({\n          frame: _this2.frame - outerFrame,\n          notification: Notification.createError(err)\n        });\n      }, function () {\n        messages.push({\n          frame: _this2.frame - outerFrame,\n          notification: Notification.createComplete()\n        });\n      });\n      return messages;\n    }\n  }, {\n    key: \"expectObservable\",\n    value: function expectObservable(observable) {\n      var _this3 = this;\n\n      var subscriptionMarbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var actual = [];\n      var flushTest = {\n        actual: actual,\n        ready: false\n      };\n      var subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n      var subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ? 0 : subscriptionParsed.subscribedFrame;\n      var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n      var subscription;\n      this.schedule(function () {\n        subscription = observable.subscribe(function (x) {\n          var value = x;\n\n          if (x instanceof Observable) {\n            value = _this3.materializeInnerObservable(value, _this3.frame);\n          }\n\n          actual.push({\n            frame: _this3.frame,\n            notification: Notification.createNext(value)\n          });\n        }, function (err) {\n          actual.push({\n            frame: _this3.frame,\n            notification: Notification.createError(err)\n          });\n        }, function () {\n          actual.push({\n            frame: _this3.frame,\n            notification: Notification.createComplete()\n          });\n        });\n      }, subscriptionFrame);\n\n      if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n        this.schedule(function () {\n          return subscription.unsubscribe();\n        }, unsubscriptionFrame);\n      }\n\n      this.flushTests.push(flushTest);\n      var runMode = this.runMode;\n      return {\n        toBe: function toBe(marbles, values, errorValue) {\n          flushTest.ready = true;\n          flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n        }\n      };\n    }\n  }, {\n    key: \"expectSubscriptions\",\n    value: function expectSubscriptions(actualSubscriptionLogs) {\n      var flushTest = {\n        actual: actualSubscriptionLogs,\n        ready: false\n      };\n      this.flushTests.push(flushTest);\n      var runMode = this.runMode;\n      return {\n        toBe: function toBe(marbles) {\n          var marblesArray = typeof marbles === 'string' ? [marbles] : marbles;\n          flushTest.ready = true;\n          flushTest.expected = marblesArray.map(function (marbles) {\n            return TestScheduler.parseMarblesAsSubscriptions(marbles, runMode);\n          });\n        }\n      };\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var _this4 = this;\n\n      var hotObservables = this.hotObservables;\n\n      while (hotObservables.length > 0) {\n        hotObservables.shift().setup();\n      }\n\n      _get(_getPrototypeOf(TestScheduler.prototype), \"flush\", this).call(this);\n\n      this.flushTests = this.flushTests.filter(function (test) {\n        if (test.ready) {\n          _this4.assertDeepEqual(test.actual, test.expected);\n\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n      var prevMaxFrames = this.maxFrames;\n      TestScheduler.frameTimeFactor = 1;\n      this.maxFrames = Number.POSITIVE_INFINITY;\n      this.runMode = true;\n      AsyncScheduler.delegate = this;\n      var helpers = {\n        cold: this.createColdObservable.bind(this),\n        hot: this.createHotObservable.bind(this),\n        flush: this.flush.bind(this),\n        expectObservable: this.expectObservable.bind(this),\n        expectSubscriptions: this.expectSubscriptions.bind(this)\n      };\n\n      try {\n        var ret = callback(helpers);\n        this.flush();\n        return ret;\n      } finally {\n        TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n        this.maxFrames = prevMaxFrames;\n        this.runMode = false;\n        AsyncScheduler.delegate = undefined;\n      }\n    }\n  }], [{\n    key: \"parseMarblesAsSubscriptions\",\n    value: function parseMarblesAsSubscriptions(marbles) {\n      var _this5 = this;\n\n      var runMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (typeof marbles !== 'string') {\n        return new SubscriptionLog(Number.POSITIVE_INFINITY);\n      }\n\n      var len = marbles.length;\n      var groupStart = -1;\n      var subscriptionFrame = Number.POSITIVE_INFINITY;\n      var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n      var frame = 0;\n\n      var _loop = function _loop(_i) {\n        var nextFrame = frame;\n\n        var advanceFrameBy = function advanceFrameBy(count) {\n          nextFrame += count * _this5.frameTimeFactor;\n        };\n\n        var c = marbles[_i];\n\n        switch (c) {\n          case ' ':\n            if (!runMode) {\n              advanceFrameBy(1);\n            }\n\n            break;\n\n          case '-':\n            advanceFrameBy(1);\n            break;\n\n          case '(':\n            groupStart = frame;\n            advanceFrameBy(1);\n            break;\n\n          case ')':\n            groupStart = -1;\n            advanceFrameBy(1);\n            break;\n\n          case '^':\n            if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n              throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n            }\n\n            subscriptionFrame = groupStart > -1 ? groupStart : frame;\n            advanceFrameBy(1);\n            break;\n\n          case '!':\n            if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n              throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n            }\n\n            unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n            break;\n\n          default:\n            if (runMode && c.match(/^[0-9]$/)) {\n              if (_i === 0 || marbles[_i - 1] === ' ') {\n                var buffer = marbles.slice(_i);\n                var match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n\n                if (match) {\n                  _i += match[0].length - 1;\n                  var duration = parseFloat(match[1]);\n                  var unit = match[2];\n                  var durationInMs;\n\n                  switch (unit) {\n                    case 'ms':\n                      durationInMs = duration;\n                      break;\n\n                    case 's':\n                      durationInMs = duration * 1000;\n                      break;\n\n                    case 'm':\n                      durationInMs = duration * 1000 * 60;\n                      break;\n\n                    default:\n                      break;\n                  }\n\n                  advanceFrameBy(durationInMs / _this5.frameTimeFactor);\n                  break;\n                }\n              }\n            }\n\n            throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' + 'subscription marble diagram. Found instead \\'' + c + '\\'.');\n        }\n\n        frame = nextFrame;\n        i = _i;\n      };\n\n      for (var i = 0; i < len; i++) {\n        _loop(i);\n      }\n\n      if (unsubscriptionFrame < 0) {\n        return new SubscriptionLog(subscriptionFrame);\n      } else {\n        return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n      }\n    }\n  }, {\n    key: \"parseMarbles\",\n    value: function parseMarbles(marbles, values, errorValue) {\n      var _this6 = this;\n\n      var materializeInnerObservables = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var runMode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      if (marbles.indexOf('!') !== -1) {\n        throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n      }\n\n      var len = marbles.length;\n      var testMessages = [];\n      var subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n      var frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n      var getValue = typeof values !== 'object' ? function (x) {\n        return x;\n      } : function (x) {\n        if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n          return values[x].messages;\n        }\n\n        return values[x];\n      };\n      var groupStart = -1;\n\n      var _loop2 = function _loop2(_i2) {\n        var nextFrame = frame;\n\n        var advanceFrameBy = function advanceFrameBy(count) {\n          nextFrame += count * _this6.frameTimeFactor;\n        };\n\n        var notification;\n        var c = marbles[_i2];\n\n        switch (c) {\n          case ' ':\n            if (!runMode) {\n              advanceFrameBy(1);\n            }\n\n            break;\n\n          case '-':\n            advanceFrameBy(1);\n            break;\n\n          case '(':\n            groupStart = frame;\n            advanceFrameBy(1);\n            break;\n\n          case ')':\n            groupStart = -1;\n            advanceFrameBy(1);\n            break;\n\n          case '|':\n            notification = Notification.createComplete();\n            advanceFrameBy(1);\n            break;\n\n          case '^':\n            advanceFrameBy(1);\n            break;\n\n          case '#':\n            notification = Notification.createError(errorValue || 'error');\n            advanceFrameBy(1);\n            break;\n\n          default:\n            if (runMode && c.match(/^[0-9]$/)) {\n              if (_i2 === 0 || marbles[_i2 - 1] === ' ') {\n                var buffer = marbles.slice(_i2);\n                var match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n\n                if (match) {\n                  _i2 += match[0].length - 1;\n                  var duration = parseFloat(match[1]);\n                  var unit = match[2];\n                  var durationInMs;\n\n                  switch (unit) {\n                    case 'ms':\n                      durationInMs = duration;\n                      break;\n\n                    case 's':\n                      durationInMs = duration * 1000;\n                      break;\n\n                    case 'm':\n                      durationInMs = duration * 1000 * 60;\n                      break;\n\n                    default:\n                      break;\n                  }\n\n                  advanceFrameBy(durationInMs / _this6.frameTimeFactor);\n                  break;\n                }\n              }\n            }\n\n            notification = Notification.createNext(getValue(c));\n            advanceFrameBy(1);\n            break;\n        }\n\n        if (notification) {\n          testMessages.push({\n            frame: groupStart > -1 ? groupStart : frame,\n            notification: notification\n          });\n        }\n\n        frame = nextFrame;\n        i = _i2;\n      };\n\n      for (var i = 0; i < len; i++) {\n        _loop2(i);\n      }\n\n      return testMessages;\n    }\n  }]);\n\n  return TestScheduler;\n}(VirtualTimeScheduler);","map":{"version":3,"sources":["C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/rxjs/_esm2015/internal/testing/TestScheduler.js"],"names":["Observable","Notification","ColdObservable","HotObservable","SubscriptionLog","VirtualTimeScheduler","VirtualAction","AsyncScheduler","defaultMaxFrame","TestScheduler","assertDeepEqual","hotObservables","coldObservables","flushTests","runMode","marbles","indexOf","Error","frameTimeFactor","values","error","messages","parseMarbles","undefined","cold","push","subject","observable","outerFrame","subscribe","value","frame","notification","createNext","err","createError","createComplete","subscriptionMarbles","actual","flushTest","ready","subscriptionParsed","parseMarblesAsSubscriptions","subscriptionFrame","subscribedFrame","Number","POSITIVE_INFINITY","unsubscriptionFrame","unsubscribedFrame","subscription","schedule","x","materializeInnerObservable","unsubscribe","toBe","errorValue","expected","actualSubscriptionLogs","marblesArray","map","length","shift","setup","filter","test","callback","prevFrameTimeFactor","prevMaxFrames","maxFrames","delegate","helpers","createColdObservable","bind","hot","createHotObservable","flush","expectObservable","expectSubscriptions","ret","len","groupStart","nextFrame","advanceFrameBy","count","c","match","buffer","slice","duration","parseFloat","unit","durationInMs","i","materializeInnerObservables","testMessages","subIndex","replace","getValue"],"mappings":"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","sourcesContent":["import { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nconst defaultMaxFrame = 750;\nexport class TestScheduler extends VirtualTimeScheduler {\n    constructor(assertDeepEqual) {\n        super(VirtualAction, defaultMaxFrame);\n        this.assertDeepEqual = assertDeepEqual;\n        this.hotObservables = [];\n        this.coldObservables = [];\n        this.flushTests = [];\n        this.runMode = false;\n    }\n    createTime(marbles) {\n        const indexOf = marbles.indexOf('|');\n        if (indexOf === -1) {\n            throw new Error('marble diagram for time should have a completion marker \"|\"');\n        }\n        return indexOf * TestScheduler.frameTimeFactor;\n    }\n    createColdObservable(marbles, values, error) {\n        if (marbles.indexOf('^') !== -1) {\n            throw new Error('cold observable cannot have subscription offset \"^\"');\n        }\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('cold observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n        const cold = new ColdObservable(messages, this);\n        this.coldObservables.push(cold);\n        return cold;\n    }\n    createHotObservable(marbles, values, error) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('hot observable cannot have unsubscription marker \"!\"');\n        }\n        const messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n        const subject = new HotObservable(messages, this);\n        this.hotObservables.push(subject);\n        return subject;\n    }\n    materializeInnerObservable(observable, outerFrame) {\n        const messages = [];\n        observable.subscribe((value) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createNext(value) });\n        }, (err) => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createError(err) });\n        }, () => {\n            messages.push({ frame: this.frame - outerFrame, notification: Notification.createComplete() });\n        });\n        return messages;\n    }\n    expectObservable(observable, subscriptionMarbles = null) {\n        const actual = [];\n        const flushTest = { actual, ready: false };\n        const subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n        const subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ?\n            0 : subscriptionParsed.subscribedFrame;\n        const unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n        let subscription;\n        this.schedule(() => {\n            subscription = observable.subscribe(x => {\n                let value = x;\n                if (x instanceof Observable) {\n                    value = this.materializeInnerObservable(value, this.frame);\n                }\n                actual.push({ frame: this.frame, notification: Notification.createNext(value) });\n            }, (err) => {\n                actual.push({ frame: this.frame, notification: Notification.createError(err) });\n            }, () => {\n                actual.push({ frame: this.frame, notification: Notification.createComplete() });\n            });\n        }, subscriptionFrame);\n        if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n            this.schedule(() => subscription.unsubscribe(), unsubscriptionFrame);\n        }\n        this.flushTests.push(flushTest);\n        const { runMode } = this;\n        return {\n            toBe(marbles, values, errorValue) {\n                flushTest.ready = true;\n                flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n            }\n        };\n    }\n    expectSubscriptions(actualSubscriptionLogs) {\n        const flushTest = { actual: actualSubscriptionLogs, ready: false };\n        this.flushTests.push(flushTest);\n        const { runMode } = this;\n        return {\n            toBe(marbles) {\n                const marblesArray = (typeof marbles === 'string') ? [marbles] : marbles;\n                flushTest.ready = true;\n                flushTest.expected = marblesArray.map(marbles => TestScheduler.parseMarblesAsSubscriptions(marbles, runMode));\n            }\n        };\n    }\n    flush() {\n        const hotObservables = this.hotObservables;\n        while (hotObservables.length > 0) {\n            hotObservables.shift().setup();\n        }\n        super.flush();\n        this.flushTests = this.flushTests.filter(test => {\n            if (test.ready) {\n                this.assertDeepEqual(test.actual, test.expected);\n                return false;\n            }\n            return true;\n        });\n    }\n    static parseMarblesAsSubscriptions(marbles, runMode = false) {\n        if (typeof marbles !== 'string') {\n            return new SubscriptionLog(Number.POSITIVE_INFINITY);\n        }\n        const len = marbles.length;\n        let groupStart = -1;\n        let subscriptionFrame = Number.POSITIVE_INFINITY;\n        let unsubscriptionFrame = Number.POSITIVE_INFINITY;\n        let frame = 0;\n        for (let i = 0; i < len; i++) {\n            let nextFrame = frame;\n            const advanceFrameBy = (count) => {\n                nextFrame += count * this.frameTimeFactor;\n            };\n            const c = marbles[i];\n            switch (c) {\n                case ' ':\n                    if (!runMode) {\n                        advanceFrameBy(1);\n                    }\n                    break;\n                case '-':\n                    advanceFrameBy(1);\n                    break;\n                case '(':\n                    groupStart = frame;\n                    advanceFrameBy(1);\n                    break;\n                case ')':\n                    groupStart = -1;\n                    advanceFrameBy(1);\n                    break;\n                case '^':\n                    if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    subscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    advanceFrameBy(1);\n                    break;\n                case '!':\n                    if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n                        throw new Error('found a second subscription point \\'^\\' in a ' +\n                            'subscription marble diagram. There can only be one.');\n                    }\n                    unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n                    break;\n                default:\n                    if (runMode && c.match(/^[0-9]$/)) {\n                        if (i === 0 || marbles[i - 1] === ' ') {\n                            const buffer = marbles.slice(i);\n                            const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n                            if (match) {\n                                i += match[0].length - 1;\n                                const duration = parseFloat(match[1]);\n                                const unit = match[2];\n                                let durationInMs;\n                                switch (unit) {\n                                    case 'ms':\n                                        durationInMs = duration;\n                                        break;\n                                    case 's':\n                                        durationInMs = duration * 1000;\n                                        break;\n                                    case 'm':\n                                        durationInMs = duration * 1000 * 60;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                                break;\n                            }\n                        }\n                    }\n                    throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' +\n                        'subscription marble diagram. Found instead \\'' + c + '\\'.');\n            }\n            frame = nextFrame;\n        }\n        if (unsubscriptionFrame < 0) {\n            return new SubscriptionLog(subscriptionFrame);\n        }\n        else {\n            return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n        }\n    }\n    static parseMarbles(marbles, values, errorValue, materializeInnerObservables = false, runMode = false) {\n        if (marbles.indexOf('!') !== -1) {\n            throw new Error('conventional marble diagrams cannot have the ' +\n                'unsubscription marker \"!\"');\n        }\n        const len = marbles.length;\n        const testMessages = [];\n        const subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n        let frame = subIndex === -1 ? 0 : (subIndex * -this.frameTimeFactor);\n        const getValue = typeof values !== 'object' ?\n            (x) => x :\n            (x) => {\n                if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n                    return values[x].messages;\n                }\n                return values[x];\n            };\n        let groupStart = -1;\n        for (let i = 0; i < len; i++) {\n            let nextFrame = frame;\n            const advanceFrameBy = (count) => {\n                nextFrame += count * this.frameTimeFactor;\n            };\n            let notification;\n            const c = marbles[i];\n            switch (c) {\n                case ' ':\n                    if (!runMode) {\n                        advanceFrameBy(1);\n                    }\n                    break;\n                case '-':\n                    advanceFrameBy(1);\n                    break;\n                case '(':\n                    groupStart = frame;\n                    advanceFrameBy(1);\n                    break;\n                case ')':\n                    groupStart = -1;\n                    advanceFrameBy(1);\n                    break;\n                case '|':\n                    notification = Notification.createComplete();\n                    advanceFrameBy(1);\n                    break;\n                case '^':\n                    advanceFrameBy(1);\n                    break;\n                case '#':\n                    notification = Notification.createError(errorValue || 'error');\n                    advanceFrameBy(1);\n                    break;\n                default:\n                    if (runMode && c.match(/^[0-9]$/)) {\n                        if (i === 0 || marbles[i - 1] === ' ') {\n                            const buffer = marbles.slice(i);\n                            const match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n                            if (match) {\n                                i += match[0].length - 1;\n                                const duration = parseFloat(match[1]);\n                                const unit = match[2];\n                                let durationInMs;\n                                switch (unit) {\n                                    case 'ms':\n                                        durationInMs = duration;\n                                        break;\n                                    case 's':\n                                        durationInMs = duration * 1000;\n                                        break;\n                                    case 'm':\n                                        durationInMs = duration * 1000 * 60;\n                                        break;\n                                    default:\n                                        break;\n                                }\n                                advanceFrameBy(durationInMs / this.frameTimeFactor);\n                                break;\n                            }\n                        }\n                    }\n                    notification = Notification.createNext(getValue(c));\n                    advanceFrameBy(1);\n                    break;\n            }\n            if (notification) {\n                testMessages.push({ frame: groupStart > -1 ? groupStart : frame, notification });\n            }\n            frame = nextFrame;\n        }\n        return testMessages;\n    }\n    run(callback) {\n        const prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n        const prevMaxFrames = this.maxFrames;\n        TestScheduler.frameTimeFactor = 1;\n        this.maxFrames = Number.POSITIVE_INFINITY;\n        this.runMode = true;\n        AsyncScheduler.delegate = this;\n        const helpers = {\n            cold: this.createColdObservable.bind(this),\n            hot: this.createHotObservable.bind(this),\n            flush: this.flush.bind(this),\n            expectObservable: this.expectObservable.bind(this),\n            expectSubscriptions: this.expectSubscriptions.bind(this),\n        };\n        try {\n            const ret = callback(helpers);\n            this.flush();\n            return ret;\n        }\n        finally {\n            TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n            this.maxFrames = prevMaxFrames;\n            this.runMode = false;\n            AsyncScheduler.delegate = undefined;\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}