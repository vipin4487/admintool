{"ast":null,"code":"import _classCallCheck from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Work/admintool/admintool/CCSDesktopAdminTool/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Observable } from '../Observable';\nimport { Notification } from '../Notification';\nimport { ColdObservable } from './ColdObservable';\nimport { HotObservable } from './HotObservable';\nimport { SubscriptionLog } from './SubscriptionLog';\nimport { VirtualTimeScheduler, VirtualAction } from '../scheduler/VirtualTimeScheduler';\nimport { AsyncScheduler } from '../scheduler/AsyncScheduler';\nvar defaultMaxFrame = 750;\nexport var TestScheduler = /*#__PURE__*/function (_VirtualTimeScheduler) {\n  _inherits(TestScheduler, _VirtualTimeScheduler);\n\n  var _super = _createSuper(TestScheduler);\n\n  function TestScheduler(assertDeepEqual) {\n    var _this;\n\n    _classCallCheck(this, TestScheduler);\n\n    _this = _super.call(this, VirtualAction, defaultMaxFrame);\n    _this.assertDeepEqual = assertDeepEqual;\n    _this.hotObservables = [];\n    _this.coldObservables = [];\n    _this.flushTests = [];\n    _this.runMode = false;\n    return _this;\n  }\n\n  _createClass(TestScheduler, [{\n    key: \"createTime\",\n    value: function createTime(marbles) {\n      var indexOf = marbles.indexOf('|');\n\n      if (indexOf === -1) {\n        throw new Error('marble diagram for time should have a completion marker \"|\"');\n      }\n\n      return indexOf * TestScheduler.frameTimeFactor;\n    }\n  }, {\n    key: \"createColdObservable\",\n    value: function createColdObservable(marbles, values, error) {\n      if (marbles.indexOf('^') !== -1) {\n        throw new Error('cold observable cannot have subscription offset \"^\"');\n      }\n\n      if (marbles.indexOf('!') !== -1) {\n        throw new Error('cold observable cannot have unsubscription marker \"!\"');\n      }\n\n      var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n      var cold = new ColdObservable(messages, this);\n      this.coldObservables.push(cold);\n      return cold;\n    }\n  }, {\n    key: \"createHotObservable\",\n    value: function createHotObservable(marbles, values, error) {\n      if (marbles.indexOf('!') !== -1) {\n        throw new Error('hot observable cannot have unsubscription marker \"!\"');\n      }\n\n      var messages = TestScheduler.parseMarbles(marbles, values, error, undefined, this.runMode);\n      var subject = new HotObservable(messages, this);\n      this.hotObservables.push(subject);\n      return subject;\n    }\n  }, {\n    key: \"materializeInnerObservable\",\n    value: function materializeInnerObservable(observable, outerFrame) {\n      var _this2 = this;\n\n      var messages = [];\n      observable.subscribe(function (value) {\n        messages.push({\n          frame: _this2.frame - outerFrame,\n          notification: Notification.createNext(value)\n        });\n      }, function (err) {\n        messages.push({\n          frame: _this2.frame - outerFrame,\n          notification: Notification.createError(err)\n        });\n      }, function () {\n        messages.push({\n          frame: _this2.frame - outerFrame,\n          notification: Notification.createComplete()\n        });\n      });\n      return messages;\n    }\n  }, {\n    key: \"expectObservable\",\n    value: function expectObservable(observable) {\n      var _this3 = this;\n\n      var subscriptionMarbles = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n      var actual = [];\n      var flushTest = {\n        actual: actual,\n        ready: false\n      };\n      var subscriptionParsed = TestScheduler.parseMarblesAsSubscriptions(subscriptionMarbles, this.runMode);\n      var subscriptionFrame = subscriptionParsed.subscribedFrame === Number.POSITIVE_INFINITY ? 0 : subscriptionParsed.subscribedFrame;\n      var unsubscriptionFrame = subscriptionParsed.unsubscribedFrame;\n      var subscription;\n      this.schedule(function () {\n        subscription = observable.subscribe(function (x) {\n          var value = x;\n\n          if (x instanceof Observable) {\n            value = _this3.materializeInnerObservable(value, _this3.frame);\n          }\n\n          actual.push({\n            frame: _this3.frame,\n            notification: Notification.createNext(value)\n          });\n        }, function (err) {\n          actual.push({\n            frame: _this3.frame,\n            notification: Notification.createError(err)\n          });\n        }, function () {\n          actual.push({\n            frame: _this3.frame,\n            notification: Notification.createComplete()\n          });\n        });\n      }, subscriptionFrame);\n\n      if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n        this.schedule(function () {\n          return subscription.unsubscribe();\n        }, unsubscriptionFrame);\n      }\n\n      this.flushTests.push(flushTest);\n      var runMode = this.runMode;\n      return {\n        toBe: function toBe(marbles, values, errorValue) {\n          flushTest.ready = true;\n          flushTest.expected = TestScheduler.parseMarbles(marbles, values, errorValue, true, runMode);\n        }\n      };\n    }\n  }, {\n    key: \"expectSubscriptions\",\n    value: function expectSubscriptions(actualSubscriptionLogs) {\n      var flushTest = {\n        actual: actualSubscriptionLogs,\n        ready: false\n      };\n      this.flushTests.push(flushTest);\n      var runMode = this.runMode;\n      return {\n        toBe: function toBe(marbles) {\n          var marblesArray = typeof marbles === 'string' ? [marbles] : marbles;\n          flushTest.ready = true;\n          flushTest.expected = marblesArray.map(function (marbles) {\n            return TestScheduler.parseMarblesAsSubscriptions(marbles, runMode);\n          });\n        }\n      };\n    }\n  }, {\n    key: \"flush\",\n    value: function flush() {\n      var _this4 = this;\n\n      var hotObservables = this.hotObservables;\n\n      while (hotObservables.length > 0) {\n        hotObservables.shift().setup();\n      }\n\n      _get(_getPrototypeOf(TestScheduler.prototype), \"flush\", this).call(this);\n\n      this.flushTests = this.flushTests.filter(function (test) {\n        if (test.ready) {\n          _this4.assertDeepEqual(test.actual, test.expected);\n\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }, {\n    key: \"run\",\n    value: function run(callback) {\n      var prevFrameTimeFactor = TestScheduler.frameTimeFactor;\n      var prevMaxFrames = this.maxFrames;\n      TestScheduler.frameTimeFactor = 1;\n      this.maxFrames = Number.POSITIVE_INFINITY;\n      this.runMode = true;\n      AsyncScheduler.delegate = this;\n      var helpers = {\n        cold: this.createColdObservable.bind(this),\n        hot: this.createHotObservable.bind(this),\n        flush: this.flush.bind(this),\n        expectObservable: this.expectObservable.bind(this),\n        expectSubscriptions: this.expectSubscriptions.bind(this)\n      };\n\n      try {\n        var ret = callback(helpers);\n        this.flush();\n        return ret;\n      } finally {\n        TestScheduler.frameTimeFactor = prevFrameTimeFactor;\n        this.maxFrames = prevMaxFrames;\n        this.runMode = false;\n        AsyncScheduler.delegate = undefined;\n      }\n    }\n  }], [{\n    key: \"parseMarblesAsSubscriptions\",\n    value: function parseMarblesAsSubscriptions(marbles) {\n      var _this5 = this;\n\n      var runMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      if (typeof marbles !== 'string') {\n        return new SubscriptionLog(Number.POSITIVE_INFINITY);\n      }\n\n      var len = marbles.length;\n      var groupStart = -1;\n      var subscriptionFrame = Number.POSITIVE_INFINITY;\n      var unsubscriptionFrame = Number.POSITIVE_INFINITY;\n      var frame = 0;\n\n      var _loop = function _loop(_i) {\n        var nextFrame = frame;\n\n        var advanceFrameBy = function advanceFrameBy(count) {\n          nextFrame += count * _this5.frameTimeFactor;\n        };\n\n        var c = marbles[_i];\n\n        switch (c) {\n          case ' ':\n            if (!runMode) {\n              advanceFrameBy(1);\n            }\n\n            break;\n\n          case '-':\n            advanceFrameBy(1);\n            break;\n\n          case '(':\n            groupStart = frame;\n            advanceFrameBy(1);\n            break;\n\n          case ')':\n            groupStart = -1;\n            advanceFrameBy(1);\n            break;\n\n          case '^':\n            if (subscriptionFrame !== Number.POSITIVE_INFINITY) {\n              throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n            }\n\n            subscriptionFrame = groupStart > -1 ? groupStart : frame;\n            advanceFrameBy(1);\n            break;\n\n          case '!':\n            if (unsubscriptionFrame !== Number.POSITIVE_INFINITY) {\n              throw new Error('found a second subscription point \\'^\\' in a ' + 'subscription marble diagram. There can only be one.');\n            }\n\n            unsubscriptionFrame = groupStart > -1 ? groupStart : frame;\n            break;\n\n          default:\n            if (runMode && c.match(/^[0-9]$/)) {\n              if (_i === 0 || marbles[_i - 1] === ' ') {\n                var buffer = marbles.slice(_i);\n                var match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n\n                if (match) {\n                  _i += match[0].length - 1;\n                  var duration = parseFloat(match[1]);\n                  var unit = match[2];\n                  var durationInMs;\n\n                  switch (unit) {\n                    case 'ms':\n                      durationInMs = duration;\n                      break;\n\n                    case 's':\n                      durationInMs = duration * 1000;\n                      break;\n\n                    case 'm':\n                      durationInMs = duration * 1000 * 60;\n                      break;\n\n                    default:\n                      break;\n                  }\n\n                  advanceFrameBy(durationInMs / _this5.frameTimeFactor);\n                  break;\n                }\n              }\n            }\n\n            throw new Error('there can only be \\'^\\' and \\'!\\' markers in a ' + 'subscription marble diagram. Found instead \\'' + c + '\\'.');\n        }\n\n        frame = nextFrame;\n        i = _i;\n      };\n\n      for (var i = 0; i < len; i++) {\n        _loop(i);\n      }\n\n      if (unsubscriptionFrame < 0) {\n        return new SubscriptionLog(subscriptionFrame);\n      } else {\n        return new SubscriptionLog(subscriptionFrame, unsubscriptionFrame);\n      }\n    }\n  }, {\n    key: \"parseMarbles\",\n    value: function parseMarbles(marbles, values, errorValue) {\n      var _this6 = this;\n\n      var materializeInnerObservables = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n      var runMode = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n\n      if (marbles.indexOf('!') !== -1) {\n        throw new Error('conventional marble diagrams cannot have the ' + 'unsubscription marker \"!\"');\n      }\n\n      var len = marbles.length;\n      var testMessages = [];\n      var subIndex = runMode ? marbles.replace(/^[ ]+/, '').indexOf('^') : marbles.indexOf('^');\n      var frame = subIndex === -1 ? 0 : subIndex * -this.frameTimeFactor;\n      var getValue = typeof values !== 'object' ? function (x) {\n        return x;\n      } : function (x) {\n        if (materializeInnerObservables && values[x] instanceof ColdObservable) {\n          return values[x].messages;\n        }\n\n        return values[x];\n      };\n      var groupStart = -1;\n\n      var _loop2 = function _loop2(_i2) {\n        var nextFrame = frame;\n\n        var advanceFrameBy = function advanceFrameBy(count) {\n          nextFrame += count * _this6.frameTimeFactor;\n        };\n\n        var notification;\n        var c = marbles[_i2];\n\n        switch (c) {\n          case ' ':\n            if (!runMode) {\n              advanceFrameBy(1);\n            }\n\n            break;\n\n          case '-':\n            advanceFrameBy(1);\n            break;\n\n          case '(':\n            groupStart = frame;\n            advanceFrameBy(1);\n            break;\n\n          case ')':\n            groupStart = -1;\n            advanceFrameBy(1);\n            break;\n\n          case '|':\n            notification = Notification.createComplete();\n            advanceFrameBy(1);\n            break;\n\n          case '^':\n            advanceFrameBy(1);\n            break;\n\n          case '#':\n            notification = Notification.createError(errorValue || 'error');\n            advanceFrameBy(1);\n            break;\n\n          default:\n            if (runMode && c.match(/^[0-9]$/)) {\n              if (_i2 === 0 || marbles[_i2 - 1] === ' ') {\n                var buffer = marbles.slice(_i2);\n                var match = buffer.match(/^([0-9]+(?:\\.[0-9]+)?)(ms|s|m) /);\n\n                if (match) {\n                  _i2 += match[0].length - 1;\n                  var duration = parseFloat(match[1]);\n                  var unit = match[2];\n                  var durationInMs;\n\n                  switch (unit) {\n                    case 'ms':\n                      durationInMs = duration;\n                      break;\n\n                    case 's':\n                      durationInMs = duration * 1000;\n                      break;\n\n                    case 'm':\n                      durationInMs = duration * 1000 * 60;\n                      break;\n\n                    default:\n                      break;\n                  }\n\n                  advanceFrameBy(durationInMs / _this6.frameTimeFactor);\n                  break;\n                }\n              }\n            }\n\n            notification = Notification.createNext(getValue(c));\n            advanceFrameBy(1);\n            break;\n        }\n\n        if (notification) {\n          testMessages.push({\n            frame: groupStart > -1 ? groupStart : frame,\n            notification: notification\n          });\n        }\n\n        frame = nextFrame;\n        i = _i2;\n      };\n\n      for (var i = 0; i < len; i++) {\n        _loop2(i);\n      }\n\n      return testMessages;\n    }\n  }]);\n\n  return TestScheduler;\n}(VirtualTimeScheduler); //# sourceMappingURL=TestScheduler.js.map","map":null,"metadata":{},"sourceType":"module"}